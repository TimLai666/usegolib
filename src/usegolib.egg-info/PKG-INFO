Metadata-Version: 2.4
Name: usegolib
Version: 0.0.0
Summary: Python runtime + builder for calling Go shared libraries directly (MessagePack ABI).
Author: TimLai666
License-Expression: MIT
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: msgpack>=1.0.7
Provides-Extra: dev
Requires-Dist: pytest>=8.0.0; extra == "dev"
Dynamic: license-file

# usegolib

**usegolib** lets Python call Go libraries by loading a Go-built shared library directly into the Python process.

- No C/C++ glue code written by you
- No background Go process (no daemon / RPC / subprocess)
- MessagePack-based ABI

## What problem does this solve?

- You have a Go library
- You want Python users to call it like a native Python module
- You do NOT want:
  - C/C++ glue code
  - gopy-style heavy bindings
  - running a Go server or subprocess

## Model

- **Build time (CI / build machine)**: use Go toolchain + an auto-provisioned C compiler (Zig) to build a Go module into a shared library + `manifest.json`.
- **Runtime (end-user / production)**: Python loads the shared library and calls it via MessagePack. Go is not running as a service.

## Requirements

- Python 3.10+
- Go toolchain (build-time only; not required for runtime if you ship prebuilt artifacts/wheels)

## Quickstart (local build + call)

```bash
# Build an artifact from a local Go module directory
python -m usegolib build --module path/to/go/module --out out/artifact
```

```python
import usegolib

h = usegolib.load_artifact("out/artifact")
print(h.AddInt(1, 2))
```

## Version Rules (important)

- One Go module = one version per Python process
- If a module is already loaded, all subpackages must use the same version
- `version=None` defaults to `@latest` (when version resolution is enabled)
